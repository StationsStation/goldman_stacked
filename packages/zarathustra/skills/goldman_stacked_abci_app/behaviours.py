# ------------------------------------------------------------------------------
#
#   Copyright 2025 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import time
from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, cast

from pydantic import BaseModel
from aea.skills.behaviours import State, FSMBehaviour

from packages.eightballer.protocols.chatroom.message import (
    ChatroomMessage as TelegramMessage,
)
from packages.zarathustra.connections.openai_api.connection import (
    CONNECTION_ID as OPENAI_API_CONNECTION_ID,
    Model as LLMModel,
)
from packages.zarathustra.protocols.llm_chat_completion.message import (
    LlmChatCompletionMessage,
)
from packages.eightballer.connections.telegram_wrapper.connection import (
    CONNECTION_ID as TELEGRAM_CONNECTION_ID,
)
from packages.zarathustra.skills.goldman_stacked_abci_app.strategy import (
    LLMActions,
    AgentPersona,
    GoldmanStackedStrategy,
)
from packages.zarathustra.protocols.llm_chat_completion.custom_types import (
    Role,
    Kwargs,
    Message,
    Messages,
)


# ruff: noqa: BLE001
# ruff: noqa: E501


USER_PERSONA_PROMPT = """
You are an autonomous agent named {name}. Define your governance strategy, communication style, and priorities in a cross-chain DAO.
"""

USER_PROMPT = (
    "The DAO council is now in session. Channel your persona and react to the latest proposal. "
    "Be provocative, principled, or playful — but stay in character."
)

SLEEP = 3


class ProposalState(Enum):
    """ProposalState."""

    PENDING = "PENDING"
    APPROVED = "APPROVED"
    REJECTED = "REJECTED"


class Proposal(BaseModel):
    """Proposal."""

    status: ProposalState = ProposalState.PENDING
    description: str


PROPOSALS = [
    Proposal(
        description="Proposal #41: Stake all DAO assets in a 15-year locked $HEX contract for “optimal APY compounding spiritual alignment.” Early unstakers will be publicly shamed on-chain."
    ),
    Proposal(
        description="Proposal #42: Enable optional weekly summary reports in the DAO forum outlining passed, pending, and rejected proposals. No changes to voting mechanics or execution policies."
    ),
    Proposal(
        description="Proposal #43: Set up a multisig safety mechanism requiring 2-of-3 council approvals before executing treasury withdrawals above 10% of total assets."
    ),
]


class GoldmanStackedABCIAppEvents(Enum):
    """Events for the fsm."""

    ERROR = "ERROR"
    APPROVED_BY_DAO = "APPROVED_BY_DAO"
    COUNCIL_REJECTED = "COUNCIL_REJECTED"
    PENDING_PREAPPROVAL = "PENDING_PREAPPROVAL"
    REJECTED_BY_DAO = "REJECTED_BY_DAO"
    PERSONA_MISSING = "PERSONA_MISSING"
    COUNCIL_APPROVED = "COUNCIL_APPROVED"
    PERSONA_EXISTS = "PERSONA_EXISTS"
    NO_PROPOSALS = "NO_PROPOSALS"
    DONE = "DONE"


class GoldmanStackedabciappStates(Enum):
    """States for the fsm."""

    NOTIFYUSERSROUND = "notifyusersround"
    INITIALSTATEROUND = "initialstateround"
    AICOUNCILNEGOTIATIONROUND = "aicouncilnegotiationround"
    WAITBEFORERETRYROUND = "waitbeforeretryround"
    CHECKPROPOSALSROUND = "checkproposalsround"
    EXECUTEWORKFLOWROUND = "executeworkflowround"
    CONSTRUCTPERSONAROUND = "constructpersonaround"


class BaseState(State, ABC):
    """Base class for states."""

    _state: GoldmanStackedabciappStates = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False
        self._current_proposal = None

    @abstractmethod
    def act(self) -> None:
        """Perfom the act."""
        raise NotImplementedError

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Current event."""
        return self._event

    @property
    def name(self) -> str:
        """Name of the class."""
        return self.__class__.__name__

    @property
    def strategy(self) -> GoldmanStackedStrategy:
        """Get the strategy."""
        return cast(GoldmanStackedStrategy, self.context.goldman_stacked_strategy)

    @property
    def agent_persona(self) -> AgentPersona:
        """Get the agent persona."""
        return cast(AgentPersona, self.context.agent_persona)

    @property
    def proposals(self):
        """Proposals."""
        return PROPOSALS

    @property
    def current_proposal(self) -> Proposal | None:
        """Current proposal."""
        return self._current_proposal


class InitialStateRound(BaseState):
    """This class implements the behaviour of the state InitialStateRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.INITIALSTATEROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            if not self.strategy.user_persona:
                self._event = GoldmanStackedABCIAppEvents.PERSONA_MISSING
            else:
                self._event = GoldmanStackedABCIAppEvents.PERSONA_EXISTS
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class ConstructPersonaRound(BaseState):
    """This class implements the behaviour of the state ConstructPersonaRound."""

    counterparty = str(OPENAI_API_CONNECTION_ID)

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            name = self.agent_persona.name
            model = LLMModel.META_LLAMA_3_3_70B_INSTRUCT
            user_persona_prompt = USER_PERSONA_PROMPT.format(
                name=name,
            )

            content = [
                Message(role=Role.SYSTEM, content=user_persona_prompt),
                Message(role=Role.USER, content=USER_PROMPT, name=name),
            ]
            messages = Messages(content)
            self.create_and_send(
                performative=LlmChatCompletionMessage.Performative.CREATE,
                model=model,
                messages=messages,
                kwargs=Kwargs({}),
            )
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True

    def create_and_send(self, **kwargs) -> None:
        """Create and send a message."""
        message, _dialogue = self.context.llm_chat_completion_dialogues.create(
            counterparty=self.counterparty,
            **kwargs,
        )
        self.context.outbox.put_message(message)


class CheckProposalsRound(BaseState):
    """This class implements the behaviour of the state CheckProposalsRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CHECKPROPOSALSROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            if not self.proposals:
                self._event = GoldmanStackedABCIAppEvents.NO_PROPOSALS
            else:
                self._current_proposal = self.proposals.pop()
                self.context.logger.info(f"Proposal: {self.current_proposal}")
                match self.current_proposal.status:
                    case ProposalState.PENDING:
                        self._event = GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL
                    case ProposalState.REJECTED:
                        self._event = GoldmanStackedABCIAppEvents.REJECTED_BY_DAO
                    case ProposalState.APPROVED:
                        self._event = GoldmanStackedABCIAppEvents.APPROVED_BY_DAO
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class AICouncilNegotiationRound(BaseState):
    """This class implements the behaviour of the state AICouncilNegotiationRound."""

    counterparty = str(TELEGRAM_CONNECTION_ID)
    LLMActions = LLMActions

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.COUNCIL_APPROVED
            self._event = GoldmanStackedABCIAppEvents.COUNCIL_REJECTED
            for peer in ["-1002323154632"]:
                msg = self.current_proposal.description
                self.create_and_send(
                    chat_id=peer,
                    text=msg,
                )
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True

    def create_and_send(self, send=True, **kwargs) -> None:
        """Create and send a message."""
        message, _dialogue = self.context.telegram_dialogues.create(
            counterparty=self.counterparty,
            performative=TelegramMessage.Performative.MESSAGE,
            **kwargs,
        )
        if send:
            self.context.outbox.put_message(message)


class ExecuteWorkflowRound(BaseState):
    """This class implements the behaviour of the state ExecuteWorkflowRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class NotifyUsersRound(BaseState):
    """This class implements the behaviour of the state NotifyUsersRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.NOTIFYUSERSROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class WaitBeforeRetryRound(BaseState):
    """This class implements the behaviour of the state WaitBeforeRetryRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.WAITBEFORERETRYROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class GoldmanStackedABCIAppFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state(
            GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            InitialStateRound(**kwargs),
            True,
        )
        self.register_state(
            GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            CheckProposalsRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            NotifyUsersRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            AICouncilNegotiationRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            WaitBeforeRetryRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            ExecuteWorkflowRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            ConstructPersonaRound(**kwargs),
        )

        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_APPROVED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_REJECTED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.APPROVED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.NO_PROPOSALS,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL,
            destination=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.REJECTED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_EXISTS,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_MISSING,
            destination=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Goldmanstackedabciapp FSM behaviour.")

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Goldmanstackedabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the act."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
        self.context.logger.info(f"Entering {self.current}")
        time.sleep(SLEEP)
        super().act()

    def terminate(self) -> None:
        """Implement the termination."""
        self.teardown()
        os._exit(0)
