# ------------------------------------------------------------------------------
#
#   Copyright 2025 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
import time
from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, cast

from pydantic import BaseModel
from aea.skills.behaviours import State, FSMBehaviour

from packages.eightballer.protocols.chatroom.message import (
    ChatroomMessage as TelegramMessage,
)
from packages.zarathustra.connections.openai_api.connection import (
    CONNECTION_ID as OPENAI_API_CONNECTION_ID,
    Model as LLMModel,
)
from packages.zarathustra.protocols.llm_chat_completion.message import (
    LlmChatCompletionMessage,
)
from packages.eightballer.connections.telegram_wrapper.connection import (
    CONNECTION_ID as TELEGRAM_CONNECTION_ID,
)
from packages.zarathustra.skills.goldman_stacked_abci_app.strategy import (
    LLMActions,
    AgentPersona,
    GoldmanStackedStrategy,
)
from packages.zarathustra.protocols.llm_chat_completion.custom_types import (
    Role,
    Kwargs,
    Message,
    Messages,
)


# ruff: noqa: BLE001
# ruff: noqa: E501


SYSTEM_PERSONA_PROMPT = """
You are an autonomous agent named {name}. Define your governance strategy, communication style, and priorities in a cross-chain DAO.
"""

USER_PERSONA_PROMPT = """
The DAO council is now in session. Channel your persona—be provocative, principled, or playful—and introduce yourself to the group.
"""

SYSTEM_PROPOSAL_PROMPT = """
You are {name}, an AI council member in Goldman Stacked.
Below is a new DAO proposal:

\"\"\"{proposal_description}\"\"\"

Based on your persona (\"{user_persona}\"), analyze whether this proposal should be APPROVED or REJECTED.
Consider cross-chain risks, whale-capture potential, and overall DAO benefit.
Respond with a short paragraph of reasoning, ending with exactly one word: APPROVE or REJECT.
"""

USER_PROPOSAL_PROMPT = """
Stay fully in character and respond in the Telegram council chat.
Provide your vote (APPROVE or REJECT) with a brief, persona-driven rationale.
"""


SLEEP = 3


class ProposalState(Enum):
    """ProposalState."""

    PENDING = "PENDING"
    APPROVED = "APPROVED"
    REJECTED = "REJECTED"


class Proposal(BaseModel):
    """Proposal."""

    status: ProposalState = ProposalState.PENDING
    description: str


PROPOSALS = [
    Proposal(
        description="Proposal #41: Stake all DAO assets in a 15-year locked $HEX contract for “optimal APY compounding spiritual alignment.” Early unstakers will be publicly shamed on-chain."
    ),
    Proposal(
        description="Proposal #42: Enable optional weekly summary reports in the DAO forum outlining passed, pending, and rejected proposals. No changes to voting mechanics or execution policies."
    ),
    Proposal(
        description="Proposal #43: Set up a multisig safety mechanism requiring 2-of-3 council approvals before executing treasury withdrawals above 10% of total assets."
    ),
]


class GoldmanStackedABCIAppEvents(Enum):
    """Events for the fsm."""

    ERROR = "ERROR"
    APPROVED_BY_DAO = "APPROVED_BY_DAO"
    COUNCIL_REJECTED = "COUNCIL_REJECTED"
    PENDING_PREAPPROVAL = "PENDING_PREAPPROVAL"
    REJECTED_BY_DAO = "REJECTED_BY_DAO"
    PERSONA_MISSING = "PERSONA_MISSING"
    COUNCIL_APPROVED = "COUNCIL_APPROVED"
    PERSONA_EXISTS = "PERSONA_EXISTS"
    NO_PROPOSALS = "NO_PROPOSALS"
    DONE = "DONE"


class GoldmanStackedabciappStates(Enum):
    """States for the fsm."""

    NOTIFYUSERSROUND = "notifyusersround"
    INITIALSTATEROUND = "initialstateround"
    AICOUNCILNEGOTIATIONROUND = "aicouncilnegotiationround"
    WAITBEFORERETRYROUND = "waitbeforeretryround"
    CHECKPROPOSALSROUND = "checkproposalsround"
    EXECUTEWORKFLOWROUND = "executeworkflowround"
    CONSTRUCTPERSONAROUND = "constructpersonaround"


class BaseState(State, ABC):
    """Base class for states."""

    _state: GoldmanStackedabciappStates = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False
        self.context.shared_state["proposal"] = None

    @abstractmethod
    def act(self) -> None:
        """Perfom the act."""
        raise NotImplementedError

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> str | None:
        """Current event."""
        return self._event

    @property
    def name(self) -> str:
        """Name of the class."""
        return self.__class__.__name__

    @property
    def strategy(self) -> GoldmanStackedStrategy:
        """Get the strategy."""
        return cast(GoldmanStackedStrategy, self.context.goldman_stacked_strategy)

    @property
    def agent_persona(self) -> AgentPersona:
        """Get the agent persona."""
        return cast(AgentPersona, self.context.agent_persona)

    @property
    def proposals(self):
        """Proposals."""
        return PROPOSALS

    @property
    def current_proposal(self) -> Proposal | None:
        """Current proposal."""
        return self.context.shared_state["proposal"]

    @current_proposal.setter
    def current_proposal(self, proposal: Proposal):
        """Current proposal."""
        self.context.shared_state["proposal"] = proposal

    def create_and_send_to_llm(self, **kwargs) -> None:
        """Create and send a message."""
        message, _dialogue = self.context.llm_chat_completion_dialogues.create(
            counterparty=str(OPENAI_API_CONNECTION_ID),
            performative=LlmChatCompletionMessage.Performative.CREATE,
            model=LLMModel.META_LLAMA_3_3_70B_INSTRUCT,
            **kwargs,
        )
        self.context.outbox.put_message(message)

    def create_and_send_to_telegram(self, send=True, **kwargs) -> None:
        """Create and send a message."""
        message, _dialogue = self.context.telegram_dialogues.create(
            counterparty=str(TELEGRAM_CONNECTION_ID),
            performative=TelegramMessage.Performative.MESSAGE,
            **kwargs,
        )
        if send:
            self.context.outbox.put_message(message)


class InitialStateRound(BaseState):
    """This class implements the behaviour of the state InitialStateRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.INITIALSTATEROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            if not self.strategy.user_persona:
                self._event = GoldmanStackedABCIAppEvents.PERSONA_MISSING
            else:
                self._event = GoldmanStackedABCIAppEvents.PERSONA_EXISTS
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class ConstructPersonaRound(BaseState):
    """This class implements the behaviour of the state ConstructPersonaRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            name = self.agent_persona.name
            system_persona_prompt = SYSTEM_PERSONA_PROMPT.format(
                name=name,
            )
            user_persona_prompt = USER_PERSONA_PROMPT

            content = [
                Message(role=Role.SYSTEM, content=system_persona_prompt),
                Message(role=Role.USER, content=user_persona_prompt, name=name),
            ]
            messages = Messages(content)
            self.create_and_send_to_llm(
                messages=messages,
                kwargs=Kwargs({}),
            )
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class CheckProposalsRound(BaseState):
    """This class implements the behaviour of the state CheckProposalsRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CHECKPROPOSALSROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            if not self.proposals:
                self._event = GoldmanStackedABCIAppEvents.NO_PROPOSALS
            else:
                self.current_proposal = self.proposals[0]
                self.context.logger.info(f"Proposal: {self.current_proposal}")
                match self.current_proposal.status:
                    case ProposalState.PENDING:
                        self._event = GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL
                    case ProposalState.REJECTED:
                        self._event = GoldmanStackedABCIAppEvents.REJECTED_BY_DAO
                    case ProposalState.APPROVED:
                        self._event = GoldmanStackedABCIAppEvents.APPROVED_BY_DAO
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class AICouncilNegotiationRound(BaseState):
    """This class implements the behaviour of the state AICouncilNegotiationRound."""

    LLMActions = LLMActions

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.COUNCIL_APPROVED
            self._event = GoldmanStackedABCIAppEvents.COUNCIL_REJECTED
            for peer in ["-1002323154632"]:
                proposal_description = self.current_proposal.description
                self.create_and_send_to_telegram(
                    chat_id=peer,
                    text=proposal_description,
                )
                self.consider_proposal(proposal_description)

            if self.strategy.llm_responses:
                self.context.logger.info("Processing LLM responses")
                action, text = self.strategy.llm_responses.pop()
                self.context.logger.info(f"Action: {action}: {text}")
                if action == LLMActions.REPLY:
                    self.strategy.telegram_responses.append(text)
                elif action == LLMActions.WORKFLOW:
                    pass
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True

    def consider_proposal(self, proposal_description: str):
        """Consider proposal."""
        name = self.agent_persona.name
        user_persona = self.strategy.user_persona
        system_proposal_prompt = SYSTEM_PROPOSAL_PROMPT.format(
            name=name,
            proposal_description=proposal_description,
            user_persona=user_persona,
        )
        user_proposal_prompt = USER_PROPOSAL_PROMPT

        content = [
            Message(role=Role.SYSTEM, content=system_proposal_prompt),
            Message(role=Role.USER, content=user_proposal_prompt, name=name),
        ]
        messages = Messages(content)
        self.create_and_send_to_llm(
            messages=messages,
            kwargs=Kwargs({}),
        )


class ExecuteWorkflowRound(BaseState):
    """This class implements the behaviour of the state ExecuteWorkflowRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class NotifyUsersRound(BaseState):
    """This class implements the behaviour of the state NotifyUsersRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.NOTIFYUSERSROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class WaitBeforeRetryRound(BaseState):
    """This class implements the behaviour of the state WaitBeforeRetryRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.WAITBEFORERETRYROUND

    def act(self) -> None:
        """Perfom the act."""

        try:
            self._event = GoldmanStackedABCIAppEvents.DONE
        except Exception as e:
            self.context.logger.info(f"Exception in {self.name}: {e}")
            self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class GoldmanStackedABCIAppFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state(
            GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            InitialStateRound(**kwargs),
            True,
        )
        self.register_state(
            GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            CheckProposalsRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            NotifyUsersRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            AICouncilNegotiationRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            WaitBeforeRetryRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            ExecuteWorkflowRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            ConstructPersonaRound(**kwargs),
        )

        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_APPROVED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_REJECTED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.APPROVED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.NO_PROPOSALS,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL,
            destination=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.REJECTED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_EXISTS,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_MISSING,
            destination=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.INITIALSTATEROUND.value,
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Goldmanstackedabciapp FSM behaviour.")

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Goldmanstackedabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the act."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
        self.context.logger.info(f"Entering {self.current}")
        time.sleep(SLEEP)
        super().act()

    def terminate(self) -> None:
        """Implement the termination."""
        self.teardown()
        os._exit(0)
