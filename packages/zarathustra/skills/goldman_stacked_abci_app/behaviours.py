# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
#   Copyright 2025 zarathustra
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#
# ------------------------------------------------------------------------------

"""This package contains a behaviour that autogenerated from the protocol ``."""

import os
from abc import ABC, abstractmethod
from typing import Optional, Any, cast
from aea.skills.behaviours import FSMBehaviour, State
from enum import Enum

from packages.eightballer.protocols.chatroom.message import (
    ChatroomMessage as TelegramMessage,
)
from packages.zarathustra.skills.goldman_stacked_abci_app.strategy import (
    LLMActions,
    AgentPersona,
    GoldmanStackedStrategy,
)
from packages.eightballer.connections.telegram_wrapper.connection import (
    CONNECTION_ID as TELEGRAM_CONNECTION_ID,
)
from packages.zarathustra.connections.openai_api.connection import (
    CONNECTION_ID as OPENAI_API_CONNECTION_ID,
    Model as LLMModel,
)
from packages.zarathustra.protocols.llm_chat_completion.message import (
    LlmChatCompletionMessage,
)
from packages.zarathustra.protocols.llm_chat_completion.custom_types import (
    Role,
    Kwargs,
    Message,
    Messages,
)


class GoldmanStackedABCIAppEvents(Enum):
    """Events for the fsm."""

    ERROR = "ERROR"
    APPROVED_BY_DAO = "APPROVED_BY_DAO"
    COUNCIL_REJECTED = "COUNCIL_REJECTED"
    PENDING_PREAPPROVAL = "PENDING_PREAPPROVAL"
    REJECTED_BY_DAO = "REJECTED_BY_DAO"
    PERSONA_MISSING = "PERSONA_MISSING"
    COUNCIL_APPROVED = "COUNCIL_APPROVED"
    PERSONA_EXISTS = "PERSONA_EXISTS"
    NO_PROPOSALS = "NO_PROPOSALS"
    DONE = "DONE"


class GoldmanStackedabciappStates(Enum):
    """States for the fsm."""

    NOTIFYUSERSROUND = "notifyusersround"
    INITIALSTATE = "initialstate"
    AICOUNCILNEGOTIATIONROUND = "aicouncilnegotiationround"
    WAITBEFORERETRYROUND = "waitbeforeretryround"
    CHECKPROPOSALSROUND = "checkproposalsround"
    EXECUTEWORKFLOWROUND = "executeworkflowround"
    CONSTRUCTPERSONAROUND = "constructpersonaround"


class BaseState(State, ABC):
    """Base class for states."""

    _state: GoldmanStackedabciappStates = None

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._event = None
        self._is_done = False

    @abstractmethod
    def act(self) -> None:
        """Perfom the act."""
        raise NotImplementedError

    def is_done(self) -> bool:
        """Is done."""
        return self._is_done

    @property
    def event(self) -> Optional[str]:
        """Current event"""
        return self._event

    @property
    def strategy(self) -> GoldmanStackedStrategy:
        """Get the strategy."""
        return cast(GoldmanStackedStrategy, self.context.goldman_stacked_strategy)

    @property
    def agent_persona(self) -> AgentPersona:
        """Get the agent persona."""
        return cast(AgentPersona, self.context.agent_persona)


class InitialState(BaseState):
    """This class implements the behaviour of the state InitialState."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.INITIALSTATE

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.PERSONA_MISSING
        self._event = GoldmanStackedABCIAppEvents.PERSONA_EXISTS
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class ConstructPersonaRound(BaseState):
    """This class implements the behaviour of the state ConstructPersonaRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.DONE
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class CheckProposalsRound(BaseState):
    """This class implements the behaviour of the state CheckProposalsRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.CHECKPROPOSALSROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL
        self._event = GoldmanStackedABCIAppEvents.REJECTED_BY_DAO
        self._event = GoldmanStackedABCIAppEvents.APPROVED_BY_DAO
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class AICouncilNegotiationRound(BaseState):
    """This class implements the behaviour of the state AICouncilNegotiationRound."""

    counterparty = str(TELEGRAM_CONNECTION_ID)
    LLMActions = LLMActions

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.COUNCIL_APPROVED
        self._event = GoldmanStackedABCIAppEvents.REJECTED_BY_DAO
        # self._event = GoldmanStackedABCIAppEvents.ERROR
        for peer in ["-1002323154632"]:
            msg = "Blabla"
            self.create_and_send(
                chat_id=peer,
                text=msg,
            )
        self._is_done = True

    def create_and_send(self, send=True, **kwargs) -> None:
        """Create and send a message."""
        message, _dialogue = self.context.telegram_dialogues.create(
            counterparty=self.counterparty,
            performative=TelegramMessage.Performative.MESSAGE,
            **kwargs,
        )
        if send:
            self.context.outbox.put_message(message)


class ExecuteWorkflowRound(BaseState):
    """This class implements the behaviour of the state ExecuteWorkflowRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.DONE
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class NotifyUsersRound(BaseState):
    """This class implements the behaviour of the state NotifyUsersRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.NOTIFYUSERSROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.DONE
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class WaitBeforeRetryRound(BaseState):
    """This class implements the behaviour of the state WaitBeforeRetryRound."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self._state = GoldmanStackedabciappStates.WAITBEFORERETRYROUND

    def act(self) -> None:
        """Perfom the act."""
        self._event = GoldmanStackedABCIAppEvents.DONE
        # self._event = GoldmanStackedABCIAppEvents.ERROR

        self._is_done = True


class GoldmanStackedABCIAppFsmBehaviour(FSMBehaviour):
    """This class implements a simple Finite State Machine behaviour."""

    def __init__(self, **kwargs: Any) -> None:
        super().__init__(**kwargs)
        self.register_state(
            GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            CheckProposalsRound(**kwargs),
            True,
        )

        self.register_state(
            GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            NotifyUsersRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.INITIALSTATE.value, InitialState(**kwargs)
        )
        self.register_state(
            GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            AICouncilNegotiationRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            WaitBeforeRetryRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            ExecuteWorkflowRound(**kwargs),
        )
        self.register_state(
            GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            ConstructPersonaRound(**kwargs),
        )

        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_APPROVED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.COUNCIL_REJECTED,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.APPROVED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.NO_PROPOSALS,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.PENDING_PREAPPROVAL,
            destination=GoldmanStackedabciappStates.AICOUNCILNEGOTIATIONROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
            event=GoldmanStackedABCIAppEvents.REJECTED_BY_DAO,
            destination=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.EXECUTEWORKFLOWROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATE.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATE.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_EXISTS,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.INITIALSTATE.value,
            event=GoldmanStackedABCIAppEvents.PERSONA_MISSING,
            destination=GoldmanStackedabciappStates.CONSTRUCTPERSONAROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.CHECKPROPOSALSROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.NOTIFYUSERSROUND.value,
            event=GoldmanStackedABCIAppEvents.ERROR,
            destination=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
        )
        self.register_transition(
            source=GoldmanStackedabciappStates.WAITBEFORERETRYROUND.value,
            event=GoldmanStackedABCIAppEvents.DONE,
            destination=GoldmanStackedabciappStates.INITIALSTATE.value,
        )

    def setup(self) -> None:
        """Implement the setup."""
        self.context.logger.info("Setting up Goldmanstackedabciapp FSM behaviour.")

    def teardown(self) -> None:
        """Implement the teardown."""
        self.context.logger.info("Tearing down Goldmanstackedabciapp FSM behaviour.")

    def act(self) -> None:
        """Implement the act."""
        if self.current is None:
            self.context.logger.info("No state to act on.")
            self.terminate()
        self.context.logger.info(f"Entering {self.current}")
        super().act()

    def terminate(self) -> None:
        """Implement the termination."""
        self.teardown()
        os._exit(0)
